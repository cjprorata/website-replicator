// src/core/HTMLProcessor.js
const cheerio = require('cheerio');
const url = require('url');
const logger = require('../utils/logger');

class HTMLProcessor {
  constructor(options = {}) {
    this.options = {
      preserveOriginalLinks: options.preserveOriginalLinks || false,
      addTimestamp: options.addTimestamp || true,
      minifyHTML: options.minifyHTML || false,
      ...options
    };
  }

  async processHTML(html, assetMapping, baseUrl, correlationId, features = null) {
    try {
      logger.logProgress(correlationId, 'html_processing_start', {
        baseUrl,
        htmlLength: html.length,
        assetMappingSize: Object.keys(assetMapping).length
      });

      const $ = cheerio.load(html, {
        withDomLvl1: true,
        normalizeWhitespace: false,
        xmlMode: false,
        decodeEntities: false
      });

      // Add metadata about the replication
      this.addReplicationMetadata($, baseUrl, correlationId, features);

      // Process different types of references
      await this.processImageReferences($, assetMapping, baseUrl, correlationId);
      await this.processStylesheetReferences($, assetMapping, baseUrl, correlationId);
      await this.processScriptReferences($, assetMapping, baseUrl, correlationId);
      await this.processMediaReferences($, assetMapping, baseUrl, correlationId);
      await this.processLinkReferences($, assetMapping, baseUrl, correlationId);
      await this.processFormReferences($, assetMapping, baseUrl, correlationId);
      await this.processInlineStyles($, assetMapping, baseUrl, correlationId);

      // Process base tag
      this.processBaseTag($, baseUrl);

      // Clean up and optimize
      if (this.options.minifyHTML) {
        this.minifyHTML($);
      }

      const processedHTML = $.html();

      logger.logProgress(correlationId, 'html_processing_complete', {
        baseUrl,
        originalLength: html.length,
        processedLength: processedHTML.length,
        referencesUpdated: this.countUpdatedReferences($, assetMapping)
      });

      return processedHTML;
    } catch (error) {
      logger.logError(correlationId, error, {
        stage: 'html_processing',
        baseUrl
      });
      throw error;
    }
  }

  addReplicationMetadata($, baseUrl, correlationId, features = null) {
    // Add meta tags indicating this is a replicated page
    $('head').prepend(`
<!-- Generated by Gist.ai Website Replicator -->
<meta name="gist-replicator-source" content="${baseUrl}">
<meta name="gist-replicator-id" content="${correlationId}">
<meta name="gist-replicator-timestamp" content="${new Date().toISOString()}">
`);

    // Add garbage collection tracking script
    const siteId = this.extractSiteIdFromCorrelationId(correlationId);
    $('head').append(`
<script>
(function() {
  'use strict';
  
  // Garbage Collection Tracking
  // Extract site ID from current URL path
  const pathParts = window.location.pathname.split('/').filter(part => part.length > 0);
  // Look for the replicated site directory pattern: hostname_YYYY-MM-DDTHH-MM-SS-sssZ
  const SITE_ID = pathParts.find(part => 
    part.includes('_') && 
    part.match(/\\d{4}-\\d{2}-\\d{2}T\\d{2}-\\d{2}-\\d{2}-\\d{3}Z$/)
  ) || 'unknown_site';
  
  console.log('üóëÔ∏è Detected site ID:', SITE_ID, 'from path:', window.location.pathname);
  const HEARTBEAT_INTERVAL = 30000; // 30 seconds
  const SERVER_BASE = window.location.origin;
  
  let heartbeatInterval = null;
  let isPageVisible = true;
  let hasBeenActive = false;
  
  // Send heartbeat to keep site alive
  function sendHeartbeat() {
    if (!isPageVisible && hasBeenActive) return; // Don't send heartbeats when page is hidden
    
    fetch(\`\${SERVER_BASE}/api/heartbeat/\${SITE_ID}\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    }).catch(err => {
      console.warn('Heartbeat failed:', err);
    });
    
    hasBeenActive = true;
  }
  
  // Notify server when user leaves
  function notifyLeave() {
    if (!hasBeenActive) return;
    
    // Use sendBeacon for reliable delivery during page unload
    const data = JSON.stringify({});
    if (navigator.sendBeacon) {
      navigator.sendBeacon(\`\${SERVER_BASE}/api/leave/\${SITE_ID}\`, data);
    } else {
      // Fallback for older browsers
      fetch(\`\${SERVER_BASE}/api/leave/\${SITE_ID}\`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: data,
        keepalive: true
      }).catch(() => {});
    }
  }
  
  // Handle page visibility changes
  function handleVisibilityChange() {
    isPageVisible = !document.hidden;
    
    if (isPageVisible) {
      // Page became visible - resume heartbeats
      if (!heartbeatInterval) {
        sendHeartbeat(); // Send immediate heartbeat
        heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
      }
    } else {
      // Page became hidden - pause heartbeats
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
      }
    }
  }
  
  // Initialize tracking when page loads
  function initializeTracking() {
    // Send initial heartbeat
    sendHeartbeat();
    
    // Start heartbeat interval
    heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
    
    // Listen for page visibility changes
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Listen for page unload events
    window.addEventListener('beforeunload', notifyLeave);
    window.addEventListener('unload', notifyLeave);
    
    // Handle page focus/blur as backup
    window.addEventListener('focus', () => {
      if (!heartbeatInterval && isPageVisible) {
        sendHeartbeat();
        heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
      }
    });
    
    window.addEventListener('blur', () => {
      // Don't immediately stop heartbeats on blur, let visibility API handle it
    });
    
    console.log('üóëÔ∏è Garbage collection tracking initialized for site:', SITE_ID);
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeTracking);
  } else {
    initializeTracking();
  }
})();
</script>
`);

    // Add features configuration before loading experiment.js
    const featuresConfig = this.generateFeaturesConfig(features);
    $('head').append(`
<script>
  // Set features configuration before widget loads
  window.GIST_WIDGET_FEATURES = ${JSON.stringify(this.getFeaturesObject(features))};
  console.log('üéØ Features configuration set:', window.GIST_WIDGET_FEATURES);
</script>
`);

    // Add script tag to load experiment.js
    $('body').append(`
<script>
  (function() {
    const script = document.createElement('script');
    script.src = 'experiment.js';
    script.async = true;
    document.body.appendChild(script);
  })();
</script>
`);

    // Add a subtle watermark
    if (this.options.addTimestamp) {
      $('body').append(`
<div style="position:fixed;bottom:5px;right:5px;font-size:10px;color:#ccc;z-index:9999;">
Replicated ${new Date().toLocaleDateString()}
</div>
`);
    }
  }

  extractSiteIdFromCorrelationId(correlationId) {
    // The site ID should match the directory name pattern: hostname_timestamp
    // Since we don't have the hostname here, we'll use the correlation ID as a fallback
    // The actual directory name will be determined by the replicator's generateOutputPath method
    // We'll extract it from the current URL when the script runs
    return 'SITE_ID_PLACEHOLDER'; // This will be replaced by client-side JavaScript
  }

  getFeaturesObject(features) {
    if (!features || !Array.isArray(features) || features.length === 0) {
      // No features specified, use default configuration
      return {
        ask: true,      // Always enabled - core functionality
        gist: true,     // Default enabled
        remix: false,   // Default disabled
        share: false    // Default disabled
      };
    }

    // Create configuration object based on selected features
    return {
      ask: true,      // Always enabled - core functionality
      gist: features.includes('gist'),
      remix: features.includes('remix'),
      share: features.includes('share')
    };
  }

  generateFeaturesConfig(features) {
    const toolsConfig = this.getFeaturesObject(features);
    
    // Generate JavaScript code to configure the tools
    const configCode = `window.GistWidget.configureTools(${JSON.stringify(toolsConfig)});`;
    
    return configCode;
  }

  async processImageReferences($, assetMapping, baseUrl, correlationId) {
    const updatedCount = { count: 0 };

    // Process img[src]
    $('img[src]').each((i, el) => {
      const src = $(el).attr('src');
      const resolvedUrl = this.resolveUrl(src, baseUrl);
      if (assetMapping[resolvedUrl]) {
        $(el).attr('src', assetMapping[resolvedUrl]);
        if (this.options.preserveOriginalLinks) {
          $(el).attr('data-original-src', src);
        }
        updatedCount.count++;
      }
    });

    // Process img[data-src] (lazy loading)
    $('img[data-src]').each((i, el) => {
      const dataSrc = $(el).attr('data-src');
      const resolvedUrl = this.resolveUrl(dataSrc, baseUrl);
      if (assetMapping[resolvedUrl]) {
        $(el).attr('data-src', assetMapping[resolvedUrl]);
        if (this.options.preserveOriginalLinks) {
          $(el).attr('data-original-data-src', dataSrc);
        }
        updatedCount.count++;
      }
    });

    // Process srcset attributes
    $('img[srcset], source[srcset]').each((i, el) => {
      const srcset = $(el).attr('srcset');
      if (srcset) {
        const updatedSrcset = this.updateSrcset(srcset, assetMapping, baseUrl);
        if (updatedSrcset !== srcset) {
          $(el).attr('srcset', updatedSrcset);
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-srcset', srcset);
          }
          updatedCount.count++;
        }
      }
    });

    // Process background images in style attributes
    $('[style*="background-image"]').each((i, el) => {
      const style = $(el).attr('style');
      const updatedStyle = this.updateBackgroundImages(style, assetMapping, baseUrl);
      if (updatedStyle !== style) {
        $(el).attr('style', updatedStyle);
        if (this.options.preserveOriginalLinks) {
          $(el).attr('data-original-style', style);
        }
        updatedCount.count++;
      }
    });

    logger.logProgress(correlationId, 'images_processed', {
      updatedCount: updatedCount.count
    });
  }

  async processStylesheetReferences($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    $('link[rel="stylesheet"]').each((i, el) => {
      const href = $(el).attr('href');
      if (href) {
        const resolvedUrl = this.resolveUrl(href, baseUrl);
        if (assetMapping[resolvedUrl]) {
          $(el).attr('href', assetMapping[resolvedUrl]);
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-href', href);
          }
          updatedCount++;
        }
      }
    });

    logger.logProgress(correlationId, 'stylesheets_processed', {
      updatedCount
    });
  }

  async processScriptReferences($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    $('script[src]').each((i, el) => {
      const src = $(el).attr('src');
      if (src) {
        const resolvedUrl = this.resolveUrl(src, baseUrl);
        if (assetMapping[resolvedUrl]) {
          $(el).attr('src', assetMapping[resolvedUrl]);
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-src', src);
          }
          updatedCount++;
        }
      }
    });

    logger.logProgress(correlationId, 'scripts_processed', {
      updatedCount
    });
  }

  async processMediaReferences($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    // Process video sources
    $('video[src], video source[src]').each((i, el) => {
      const src = $(el).attr('src');
      if (src) {
        const resolvedUrl = this.resolveUrl(src, baseUrl);
        if (assetMapping[resolvedUrl]) {
          $(el).attr('src', assetMapping[resolvedUrl]);
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-src', src);
          }
          updatedCount++;
        }
      }
    });

    // Process audio sources
    $('audio[src], audio source[src]').each((i, el) => {
      const src = $(el).attr('src');
      if (src) {
        const resolvedUrl = this.resolveUrl(src, baseUrl);
        if (assetMapping[resolvedUrl]) {
          $(el).attr('src', assetMapping[resolvedUrl]);
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-src', src);
          }
          updatedCount++;
        }
      }
    });

    logger.logProgress(correlationId, 'media_processed', {
      updatedCount
    });
  }

  async processLinkReferences($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    // Handle internal links
    $('a[href]').each((i, el) => {
      const href = $(el).attr('href');
      if (href && !href.startsWith('#') && !href.startsWith('mailto:') &&
          !href.startsWith('tel:') && !href.startsWith('javascript:')) {
        
        const resolvedUrl = this.resolveUrl(href, baseUrl);
        
        // Check if this is an internal link within the same domain
        if (this.isSameDomain(resolvedUrl, baseUrl)) {
          // For now, preserve the original link but add a warning
          $(el).attr('title', 'Original link - may not work in replicated version');
          if (this.options.preserveOriginalLinks) {
            $(el).attr('data-original-href', href);
          }
        }
        
        // Check if it's a downloadable asset
        if (assetMapping[resolvedUrl]) {
          $(el).attr('href', assetMapping[resolvedUrl]);
          updatedCount++;
        }
      }
    });

    logger.logProgress(correlationId, 'links_processed', {
      updatedCount
    });
  }

  async processFormReferences($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    $('form[action]').each((i, el) => {
      const action = $(el).attr('action');
      if (action) {
        // Add warning that forms won't work in replicated version
        $(el).attr('data-original-action', action);
        $(el).attr('action', '#');
        $(el).attr('onsubmit', 'alert("This form is not functional in the replicated version"); return false;');
        
        // Add a visual indicator
        $(el).prepend('<div style="background:#fff3cd;border:1px solid #ffeaa7;padding:8px;margin:8px 0;border-radius:4px;">‚ö†Ô∏è Form disabled in replicated version</div>');
        
        updatedCount++;
      }
    });

    logger.logProgress(correlationId, 'forms_processed', {
      updatedCount
    });
  }

  async processInlineStyles($, assetMapping, baseUrl, correlationId) {
    let updatedCount = 0;

    $('style').each((i, el) => {
      const cssContent = $(el).html();
      if (cssContent) {
        const updatedCSS = this.updateCSSUrls(cssContent, assetMapping, baseUrl);
        if (updatedCSS !== cssContent) {
          $(el).html(updatedCSS);
          updatedCount++;
        }
      }
    });

    logger.logProgress(correlationId, 'inline_styles_processed', {
      updatedCount
    });
  }

  processBaseTag($, baseUrl) {
    // Remove or update base tag to prevent conflicts
    const $base = $('base[href]');
    if ($base.length > 0) {
      $base.attr('data-original-href', $base.attr('href'));
      $base.remove(); // Remove base tag to use relative paths
    }
  }

  updateSrcset(srcset, assetMapping, baseUrl) {
    return srcset.split(',').map(src => {
      const parts = src.trim().split(/\s+/);
      const url = parts[0];
      const descriptor = parts[1] || '';
      
      const resolvedUrl = this.resolveUrl(url, baseUrl);
      const mappedUrl = assetMapping[resolvedUrl] || url;
      
      return descriptor ? `${mappedUrl} ${descriptor}` : mappedUrl;
    }).join(', ');
  }

  updateBackgroundImages(style, assetMapping, baseUrl) {
    return style.replace(/background-image:\s*url\(['"]?([^'"]+)['"]?\)/g, (match, url) => {
      const resolvedUrl = this.resolveUrl(url, baseUrl);
      const mappedUrl = assetMapping[resolvedUrl] || url;
      return `background-image: url('${mappedUrl}')`;
    });
  }

  updateCSSUrls(css, assetMapping, baseUrl) {
    return css.replace(/url\(['"]?([^'"]+)['"]?\)/g, (match, url) => {
      if (url.startsWith('data:') || url.startsWith('#')) {
        return match;
      }
      
      const resolvedUrl = this.resolveUrl(url, baseUrl);
      const mappedUrl = assetMapping[resolvedUrl] || url;
      return `url('${mappedUrl}')`;
    });
  }

  resolveUrl(relativeUrl, baseUrl) {
    try {
      return url.resolve(baseUrl, relativeUrl);
    } catch (error) {
      return relativeUrl;
    }
  }

  isSameDomain(url1, url2) {
    try {
      const domain1 = new URL(url1).hostname;
      const domain2 = new URL(url2).hostname;
      return domain1 === domain2;
    } catch (error) {
      return false;
    }
  }

  minifyHTML($) {
    // Remove comments
    $('*').contents().each(function() {
      if (this.type === 'comment') {
        $(this).remove();
      }
    });

    // Remove extra whitespace (basic implementation)
    $('script, style').each(function() {
      const content = $(this).html();
      if (content) {
        // Preserve script and style content as-is
        $(this).html(content);
      }
    });
  }

  countUpdatedReferences($, assetMapping) {
    let count = 0;
    const selectors = [
      'img[src]', 'img[data-src]', 'img[srcset]', 'source[srcset]',
      'link[rel="stylesheet"]', 'script[src]', 'video[src]', 'audio[src]',
      'a[href]', '[style*="background-image"]'
    ];

    selectors.forEach(selector => {
      count += $(selector).length;
    });

    return count;
  }
}

module.exports = HTMLProcessor;